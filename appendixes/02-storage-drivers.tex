\chapter{Storage drivers}
When it comes to handle a container file system, different solutions can be used.  The goal of each is to provide the most efficient writable root directory (\texttt{/}) for each container, but keeping each container inaffected by the modifification done in the other containers.

\paragraph{}In order to do so, three main strategies can be used:
\begin{itemize}
\renewcommand\labelitemi{--}
  \item \textbf{Deep copy}: for each container, the whole image is copied during the creation of the container.  This is simple, but gets terribly slow as the file system size increases.
  \item \textbf{File based copy on write}: for each container, will be copied only the files that are edited during the container life cycle.  This is more complex, but get more efficient as the container's size grows.
  \item \textbf{Block based copy on write}: for each container, will be copied only the blocks (in the filesystem) that are edited during the container life cycle.  This is even more complex, but get more efficient as some small part of big files are edited.
\end{itemize}

\paragraph{}Containers are a specific kind of workload in the sense that many information, data, is redundant in different containers.  For example, for a simple application, we could use several containers with different responsabilities and tools embedded in it, but all based on the same Alpine image.  This brought a new space problem, as we don't want to avoid duplicating too much data.  In order to face this, \textbf{union filesystems} are used, along with layered container images.  This basically means that different container images but with the same basis, will actually share this same basis, avoiding the need to duplicate it.

\paragraph{}Here is a non-exhaustive list of current available solutions for container storage:
\begin{itemize}
\renewcommand\labelitemi{--}
  \item \texttt{overlay} and \textbf{overlay2} (\textit{Docker}): Those are based on OverlayFS (Linux kernel driver), a union filesystem, similar to AUFS, but Docker claims it to be faster and simpler.  Overlay2 is the new and more stable version of overlay.
  \item \texttt{aufs} (\textit{Docker}): This solution is based on AUFS, a union filesystem.  For Docker, it was the predecessor of overlay, and is a bit less performant than the latest.
  \item \texttt{btrfs} (\textit{Docker}, \textit{LXC}):  Btrfs is a copy-on-write filesystem.  Docker's and LXC's btrfs storage driver rely directly on it, using its block-level capabilities, thin provisionning and its copy-on-write snapshots.
  \item \texttt{zfs} (\textit{Docker}, \textit{LXC}): ZFS is another filesystem, with many features, like snapshots, compression, deduplication and more.  Docker's and LXC's zfs storage driver rely on it, taking advantages of its capabilities.
  \item \texttt{vfs} (\textit{Docker}):  This is the simplest and yet more reliable storage driver.  As it doesn't provide any advanced feature.  It as no copy-on-write capabilities.  Each container filesystem is compied on creation.  The performances of this driver are very poor then.
  \item \texttt{directory} (\textit{LXC}):  This is the exact equivalent of vfs.
  \item \texttt{devicemapper} (\textit{Docker}) [deprecated]:  This relies on Device Mapper, a kernel-base framework with some interesting capabilities as snapshots and thin provisionning.  This is a block-based approach.
  \item \texttt{lvm} (\textit{LXC}):  This is the exact equivalent of devicemapper.
\end{itemize}

\textbf{Note} that the \texttt{storage} Go library for containers, wrapped under the \texttt{containers-storage} CLI\footnote{\href{https://github.com/containers/storage}{https://github.com/containers/storage}} provide support for all of those drivers\footnote{\href{https://github.com/containers/storage/tree/master/drivers}{https://github.com/containers/storage/tree/master/drivers}}.
